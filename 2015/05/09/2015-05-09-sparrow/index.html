<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sparrow: Distributed, Low Latency Scheduling | ShallWe Talk</title>
  <meta name="author" content="6carol6">
  
  <meta name="description" content="这是UC Berkeley的一篇设计分布式系统中的调度的文章，作者是个萌妹纸。本来想贴张照片，想想算了不侵犯人家肖像权，大家自行百度就可以了（偷偷说一句微博上有高清大图）。嗷~~~文章发表在SOSP’13。  
###Abstract####
总之就是设计了一个非集中式的，随机采样的方法来实现调度，达到了接近最优的性能。嗯。  
为什么说接近最优呢？人家在一个110个机器的集群上进行了测试，表示Sparrow(哦对，这个调度叫Sparrow)的性能能够达到理想的调度算法的12%以内。至于是哪些性能指标，读下去再说吧。  
###1 Introduction###
现如今的数据分析集群都跑些越来越短的高扇出的工作。然后就有很多框架做出来满足这些需求（比如Dremel, Spark, Impala等等）。总之就是这些框架的速度越来越快了，作者还给了张图证明了随着时代的发展，数据分析框架的时延越来越低了。人们想了各种方法来使得时延变低，非常辛苦。由于这些系统都是分布式系统，所以调度不能拖后腿啊。于是就有了这篇文章的工作。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Sparrow: Distributed, Low Latency Scheduling"/>
  <meta property="og:site_name" content="ShallWe Talk"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="ShallWe Talk" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">ShallWe Talk</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-09T14:36:07.000Z"><a href="/2015/05/09/2015-05-09-sparrow/">2015-05-09</a></time>
      
      
  
    <h1 class="title">Sparrow: Distributed, Low Latency Scheduling</h1>
  

    </header>
    <div class="entry">
      
        <p>这是UC Berkeley的一篇设计分布式系统中的调度的文章，作者是个萌妹纸。本来想贴张照片，想想算了不侵犯人家肖像权，大家自行百度就可以了（偷偷说一句微博上有高清大图）。嗷~~~文章发表在SOSP’13。  </p>
<p>###Abstract####</p>
<p>总之就是设计了一个非集中式的，随机采样的方法来实现调度，达到了接近最优的性能。嗯。  </p>
<p>为什么说接近最优呢？人家在一个110个机器的集群上进行了测试，表示Sparrow(哦对，这个调度叫Sparrow)的性能能够达到理想的调度算法的12%以内。至于是哪些性能指标，读下去再说吧。  </p>
<p>###1 Introduction###</p>
<p>现如今的数据分析集群都跑些越来越短的高扇出的工作。然后就有很多框架做出来满足这些需求（比如Dremel, Spark, Impala等等）。总之就是这些框架的速度越来越快了，作者还给了张图证明了随着时代的发展，数据分析框架的时延越来越低了。人们想了各种方法来使得时延变低，非常辛苦。由于这些系统都是分布式系统，所以调度不能拖后腿啊。于是就有了这篇文章的工作。<br><a id="more"></a><br>Sparrow是一个分布式的调度器，使用了two choices load balancing technique。这种技术调度每个task都探查两个随机的server然后把task交给排队等待任务较少的server。Sparrow使用了以下三种技术来make the power of two choices effective。<br><strong>Batch Sample:</strong> 由于一个job的response time（就是从一个job提交开始到这个job的所有task都完成所使用的时间）与最后一个task的等待时间有关，然而这个等待时间会由于在两个选择之间抉择而变慢，所以对于并行job，two choices的这种做法表现得并不好。Batch Sampling利用了一种multiple choices approach[1]解决了这个问题。<br><strong>Late Binding:</strong> 然而two choices的性能还受到两方面的影响： 首先，server上等待队列的长度并不能很好地反应等待时间。其次，消息会有时延，多个调度器并行工作可能会产生竞争。Late binding能够解决这个问题。具体的做法是延迟task提交到worker的时间直到woker已经准备好为这个task工作。这种做法与只用Batch Sample相比较能够平均减少45%的response time。<br><strong>Policies and Constraints:</strong> Sparrow在每个工作节点上都使用了多个队列用来enforce global policies(这是什么鬼？)还有支持per-job and per-task placement constraints needed by analytics frameworks(这又是什么鬼？)。总之就是这两个功能十分重要就对了。  </p>
<p>然后就简要介绍了一些测试和结果。Introduction部分就完了。  </p>
<p>###2 Design Goals###</p>
<p>本文关注的是低时延应用的细粒度任务调度。低时延的workloads比批处理的workloads需要更频繁的调度。  </p>
<p>Sparrow并没有为每一个task开一个进程，而是假设每一个framework在每一个worker上都有一个都有一个long-running executor process在运行，这样，Sparrow只需要在一个task被launched的时候发送一个short task description（而不是a large binary）就行了。（这是为什么？）这些executor process可以在cluster resource manager(例如YARN, Mesos, Omega)给Sparrow和其他frameworks(例如传统的批处理workloads)分配资源的时候执行？  </p>
<p>Sparrow也有一些无法做到的事情。Sparrow无法保证placement constraints(例如，我的job不能被放在User X的工作被运行的worker上)。Sparrow也不支持<a href="http://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="external">bin packing</a>和<a href="http://en.wikipedia.org/wiki/Gang_scheduling" target="_blank" rel="external">gang scheduling</a>。   </p>
<p>但Sparrow也因此变得简单高效。而且对于一些基本的约束Sparrow还是可以支持的。比如per-task constraints(每个task必须跟输入数据共驻主存)，还有per-job constraints(每个task必须被放在有GPU的machine上)。这些特性与Hadoop MapReduce scheduler和Spark scheduler类似。  </p>
<p>###3 Sample-Based Scheduling for Parallel Jobs###</p>
<p>一个传统的任务调度算法需要对全局有一个完整的视图，应该知道哪一个task运行在哪一个worker上，然后再对接下来的task分配可用的worker。然而Sparrow用的并不是这种方式：Sparrow并行执行多个schedulers，每一个scheduler并不用维护cluster load的状态。为了调度job的task，schedulers只依赖当前瞬时的load信息。</p>
<p>####3.1 Terminology and job model####</p>
<p>定义一个cluster由worker machines和schedulers组成。一个有着m个tasks的job会把各个task分在这些worker上执行。job可以被任意scheduler调度。woker在固定数量的slots内执行tasks。如果一个woker收到了更多的task但它已经无法并发执行了，就给新task排队，直到有足够的资源供新task执行。</p>
<p>接下来定义了一些时间：</p>
<ul>
<li>wait time: 一个task从提交到执行经过的时间</li>
<li>service time: 一个task的执行时间</li>
<li>job response time: 一个job从提交到最后一个task完成经过的时间</li>
<li>delay: 一个job在调度和排队上花费的总时间</li>
</ul>
<p>本文假设每个job只有一波tasks。就是说，m大于user分配的slots。对于多波task的job，scheduler可以把一些early tasks放在有着longer queueing delay的machines上，这样就不会影响job response time。（这个么看懂）。反正就是测的时候只测一波的就对了。  </p>
<p>####3.2 Per-task sampling####</p>
<p>第一段就是说我们要用two choices technique，刚才已经说过了，就是要调度的时候随机选两个woker然后发两个探查（探查是一个lightweight RPC），然后两个worker就会发回复说现在它们这儿排的队有多长，然后scheduler就选短的那个，让这个task去短的woker上排队。这个调度算法就像下图中的(a)一样。这种做法就叫做Per-task sampling。</p>
<p><img src="http://i766.photobucket.com/albums/xx304/mszxw999/blog/QQ20150510100237.png" alt="two choices technique &amp; batch sampling"></p>
<p>####3.3 Batch sampling####</p>
<p>由于Per-task sampling的做法太慢了，而且如果探查的两个worker队列都很长（Task1），就会得到非常不好的结果。batch sampling允许对一个job共享探查的结果。每次探查dm个worker，然后选出load最小的m个worker。就像上图中的(b)那样。这个d是可以选择的，上图选择d=2。</p>
<p>####3.4 Problems with sample-based scheduling####</p>
<p>sample-based调度有一些什么缺点呢？  </p>
<p>首先，调度要更具worker节点上队列长度来进行。然而队列长度并不能很好地表示等待时间。考虑到有两个队伍，一个队伍有两个50ms的任务，而另一个上面有1个300ms的任务。这时候选后一个队伍就不合适了。然而预测task所需要的时间是非常困难的。  </p>
<p>其次，sampling会遇到竞争的情况。当多个不同的schedulers同时探查同一个空闲的worker的时候，由于这个worker是空闲的，它们都倾向于选择这个worker。这样就会造成大家都往同一个worker上放task的情况。  </p>
<p>####3.5 Late binding####</p>
<p>Late binding就是为了解决3.4节中提出的竞争问题的，worker并不立即返回探查结果，而是放一个这个task的reservation在队伍的末尾，当这个reservation跑到队头的时候，worker向scheduler发送一个PRC。每个scheduler把job的task提交给最初发回应的m个worker，然后给其它(d-1)m个worker发一个no-op的信号。  </p>
<p>这种做法的一个缺点是当worker向scheduler发送一个RPC请求一个新的task的时候，worker是空闲的。这时候可以用一个tradeoff来解决这个问题：当一个worker有足够资源的时候就发RPC？  </p>
<p>####3.6 Proactive Cancellation####</p>
<p>（刚看到这个小标题我都傻了，这啥意思啊？主动取消？取消啥？接着看下去~）  </p>
<p>当一个scheduler发射了一个job的所有task时，它可以用以下方式处理那些没发过回复的探查（其它worker上的探查，它们太慢了）：可以由scheduler主动向worker发取消请求，或者可以等待worker发回复请求task的时候回复说这个task已经被处理过了。经过他们研究表明前一种做法能够获得更好的结果。  </p>
<p>####4 Scheduling Policies and Constraints####</p>
<p>这部分讲的是Sparrow能够支持的两个sheduler policies。这个在第2章的时候曾经提过。  </p>
<p>####4.1 Handling placement constriants####</p>
<p>Sparrow能够支持两种约束(constraints)，分别是per-job和per-task constraints。这些约束会被用在一些data-parallel frameworks里，比如需要把task交给硬盘或内存里存有输入数据的机器。  </p>
<p>读到这里大概有种感觉，这个调度算法是为spark写的啦~  </p>
<p>####4.2 Resource allocation policies####</p>
<p>[1] G. Park. A Generalization of Multiple Choice Balls-into-Bins. In Proc. PODC, pages 297–298, 2011.</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/paper/">paper</a>, <a href="/categories/paper/scheduler/">scheduler</a>
  </div>

        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Kommentare</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2015/05/09/2015-05-09-sparrow/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Kategorien</h3>
  <ul class="entry">
  
    <li><a href="/categories/software-engineer/API/">API</a><small>1</small></li>
  
    <li><a href="/categories/Beijing/">Beijing</a><small>1</small></li>
  
    <li><a href="/categories/C语言学习笔记/">C语言学习笔记</a><small>1</small></li>
  
    <li><a href="/categories/leetcode/HashTable/">HashTable</a><small>1</small></li>
  
    <li><a href="/categories/source-code/JXIO/">JXIO</a><small>1</small></li>
  
    <li><a href="/categories/language/Japanese/">Japanese</a><small>2</small></li>
  
    <li><a href="/categories/paper/NLP/">NLP</a><small>1</small></li>
  
    <li><a href="/categories/Spark/RDD/">RDD</a><small>1</small></li>
  
    <li><a href="/categories/Security/">Security</a><small>1</small></li>
  
    <li><a href="/categories/Spark/">Spark</a><small>2</small></li>
  
    <li><a href="/categories/source-code/Spark/">Spark</a><small>5</small></li>
  
    <li><a href="/categories/leetcode/Two-Pointers/">Two Pointers</a><small>1</small></li>
  
    <li><a href="/categories/unity/UGUI/">UGUI</a><small>1</small></li>
  
    <li><a href="/categories/unity/animation/">animation</a><small>1</small></li>
  
    <li><a href="/categories/blog/">blog</a><small>3</small></li>
  
    <li><a href="/categories/coding/">coding</a><small>1</small></li>
  
    <li><a href="/categories/coding/compiler/">compiler</a><small>1</small></li>
  
    <li><a href="/categories/Spark/configuration/">configuration</a><small>1</small></li>
  
    <li><a href="/categories/leetcode/divide-and-conquer/">divide and conquer</a><small>1</small></li>
  
    <li><a href="/categories/dp/">dp</a><small>1</small></li>
  
    <li><a href="/categories/leetcode/dp/">dp</a><small>1</small></li>
  
    <li><a href="/categories/music/guitar/">guitar</a><small>1</small></li>
  
    <li><a href="/categories/language/">language</a><small>2</small></li>
  
    <li><a href="/categories/leetcode/">leetcode</a><small>9</small></li>
  
    <li><a href="/categories/language/Japanese/lyric/">lyric</a><small>1</small></li>
  
    <li><a href="/categories/mapreduce/">mapreduce</a><small>1</small></li>
  
    <li><a href="/categories/python/matplotlib/">matplotlib</a><small>1</small></li>
  
    <li><a href="/categories/music/">music</a><small>1</small></li>
  
    <li><a href="/categories/paper/">paper</a><small>2</small></li>
  
    <li><a href="/categories/programming-language/">programming language</a><small>1</small></li>
  
    <li><a href="/categories/python/">python</a><small>1</small></li>
  
    <li><a href="/categories/paper/scheduler/">scheduler</a><small>1</small></li>
  
    <li><a href="/categories/software-engineer/">software engineer</a><small>1</small></li>
  
    <li><a href="/categories/Spark/RDD/source-code/">source code</a><small>1</small></li>
  
    <li><a href="/categories/source-code/">source code</a><small>6</small></li>
  
    <li><a href="/categories/spark/">spark</a><small>2</small></li>
  
    <li><a href="/categories/unity/">unity</a><small>2</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner">
<div class="alignleft">
  <script src="//dn-lbstatics.qbox.me/lbservice/busuanzi/2.0/busuanzi.mini.js"/></script>
  <span id="busuanzi_container_site_uv">已经有<span id="busuanzi_value_site_uv"></span>人次访问carolz的小站啦 ( •̀ ω •́ )y</span>
  <br /><br />
  
  &copy; 2017 6carol6
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
