<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Dynamic Resource Allocation | ShallWe Talk</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Dynamic Resource Allocation</h1><a id="logo" href="/.">ShallWe Talk</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Accueil</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> À propos</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Dynamic Resource Allocation</h1><div class="post-meta">Apr 9, 2017<span> | </span><span class="category"><a href="/categories/source-code/">source code</a><a href="/categories/source-code/Spark/">Spark</a></span></div><div class="post-content"><p>嘛，今天具体就从源码的角度介绍下<a href="http://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation" target="_blank" rel="external">这个</a>  </p>
<p>这货貌似在Spark1.2的时候就被引入了，居然现在才看真是惭愧啊。  </p>
<a id="more"></a>
<h3 id="ExecutorAllocationManager-scala"><a href="#ExecutorAllocationManager-scala" class="headerlink" title="ExecutorAllocationManager.scala"></a>ExecutorAllocationManager.scala</h3><p>在<code>SparkContext</code>里会调用这个类的<code>start()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Register for scheduler callbacks to decide when to add and remove executors, and start</div><div class="line">    * the scheduling task.</div><div class="line">    */</div><div class="line">    def start(): Unit = &#123;</div><div class="line">        listenerBus.addListener(listener)</div><div class="line"></div><div class="line">        val scheduleTask = new Runnable() &#123;</div><div class="line">            override def run(): Unit = &#123;</div><div class="line">                try &#123;</div><div class="line">                    schedule()</div><div class="line">                &#125; catch &#123;</div><div class="line">                case ct: ControlThrowable =&gt;</div><div class="line">                    throw ct</div><div class="line">                case t: Throwable =&gt;</div><div class="line">                    logWarning(s&quot;Uncaught exception in thread $&#123;Thread.currentThread().getName&#125;&quot;, t)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        executor.scheduleAtFixedRate(scheduleTask, 0, intervalMillis, TimeUnit.MILLISECONDS)</div><div class="line"></div><div class="line">        client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>schedule()</code>在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * This is called at a fixed interval to regulate the number of pending executor requests</div><div class="line">   * and number of executors running.</div><div class="line">   *</div><div class="line">   * First, adjust our requested executors based on the add time and our current needs.</div><div class="line">   * Then, if the remove time for an existing executor has expired, kill the executor.</div><div class="line">   *</div><div class="line">   * This is factored out into its own method for testing.</div><div class="line">   */</div><div class="line">  private def schedule(): Unit = synchronized &#123;</div><div class="line">    val now = clock.getTimeMillis</div><div class="line"></div><div class="line">    updateAndSyncNumExecutorsTarget(now)</div><div class="line"></div><div class="line">    // 这里的removeTimes是一个HashMap[String, Long]（&lt;ExecutorId, expireTime&gt;）</div><div class="line">    // 超时未被占用，移除Executor</div><div class="line">    removeTimes.retain &#123; case (executorId, expireTime) =&gt;</div><div class="line">      val expired = now &gt;= expireTime</div><div class="line">      if (expired) &#123;</div><div class="line">        initializing = false</div><div class="line">        removeExecutor(executorId)</div><div class="line">      &#125;</div><div class="line">      !expired</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>updateAndSyncNumExecutorsTarget(now)</code>里调用<code>addExecutors()</code>，这里是每次翻倍申请Executor的地方。</p>
<p>然后回到最上面的<code>start()</code>，有一个<code>Runnable()</code>什么时候<code>run()</code>呢，可以看到这个<code>Runnable()</code>被传入了<code>executor.scheduleAtFixedRate(scheduleTask, 0, intervalMillis, TimeUnit.MILLISECONDS)</code>。这里的<code>executor</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Executor that handles the scheduling task.</div><div class="line">private val executor =</div><div class="line">  ThreadUtils.newDaemonSingleThreadScheduledExecutor(&quot;spark-dynamic-executor-allocation&quot;)</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="util-ThreadUtils-scala"><a href="#util-ThreadUtils-scala" class="headerlink" title="util/ThreadUtils.scala"></a>util/ThreadUtils.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   /**</div><div class="line">&gt;    * Wrapper over newSingleThreadExecutor.</div><div class="line">&gt;    */</div><div class="line">&gt;   def newDaemonSingleThreadExecutor(threadName: String): ExecutorService = &#123;</div><div class="line">&gt;     val threadFactory = new ThreadFactoryBuilder().setDaemon(true).setNameFormat(threadName).build()</div><div class="line">&gt;     Executors.newSingleThreadExecutor(threadFactory)</div><div class="line">&gt;   &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>这应该是一个工厂模式，返回了一个<code>ExecutorService</code>。所以<code>executor.scheduleAtFixedRate(scheduleTask, 0, intervalMillis, TimeUnit.MILLISECONDS)</code>应该可以被理解为每隔<code>intervalMillis</code>时间就被调用一下啦。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Polling loop interval (ms)</div><div class="line">private val intervalMillis: Long = 100</div></pre></td></tr></table></figure>
<p>这个时间间隔被定义为了100ms。</p>
<p>我们现在知道了申请Executor的函数会每隔100ms被调用一次，那么这个函数做了什么呢？</p>
<p>如果还有task在排队，并且还没有被调度，就要<code>addExecutors(maxNeeded)</code>，这里的<code>maxNeeded</code>取(task的总个数/每个task需要的Executor的个数)上取整。</p>
<p>先看一些默认值表示什么意思，值是多少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Lower and upper bounds on the number of executors.</div><div class="line">//最小的Executor数量，默认为0</div><div class="line">private val minNumExecutors = conf.get(DYN_ALLOCATION_MIN_EXECUTORS) </div><div class="line">//最大的Executor数量，默认为Int.MaxValue</div><div class="line">private val maxNumExecutors = conf.get(DYN_ALLOCATION_MAX_EXECUTORS) </div><div class="line">//初始请求Executor数量，为max&#123;DYN_ALLOCATION_MIN_EXECUTORS，DYN_ALLOCATION_INITIAL_EXECUTORS(默认为DYN_ALLOCATION_MIN_EXECUTORS)，EXECUTOR_INSTANCES(默认为0)&#125;</div><div class="line">private val initialNumExecutors = Utils.getDynamicAllocationInitialExecutors(conf) </div><div class="line"></div><div class="line">// The desired number of executors at this moment in time. If all our executors were to die, this</div><div class="line">// is the number of executors we would immediately want from the cluster manager.</div><div class="line">private var numExecutorsTarget = initialNumExecutors</div><div class="line"></div><div class="line">// Number of executors to add in the next round</div><div class="line">private var numExecutorsToAdd = 1</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="internal-package-scala"><a href="#internal-package-scala" class="headerlink" title="internal/package.scala"></a>internal/package.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;   private[spark] val DYN_ALLOCATION_MIN_EXECUTORS =</div><div class="line">&gt;    ConfigBuilder(&quot;spark.dynamicAllocation.minExecutors&quot;).intConf.createWithDefault(0)</div><div class="line">&gt;   private[spark] val DYN_ALLOCATION_MAX_EXECUTORS =</div><div class="line">&gt;    ConfigBuilder(&quot;spark.dynamicAllocation.maxExecutors&quot;).intConf.createWithDefault(Int.MaxValue)</div><div class="line">&gt;   private[spark] val DYN_ALLOCATION_INITIAL_EXECUTORS =</div><div class="line">&gt;    ConfigBuilder(&quot;spark.dynamicAllocation.initialExecutors&quot;)</div><div class="line">&gt;      .fallbackConf(DYN_ALLOCATION_MIN_EXECUTORS)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<h3 id="util-Utils-scala"><a href="#util-Utils-scala" class="headerlink" title="util/Utils.scala"></a>util/Utils.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;   /**</div><div class="line">&gt;   * Return the initial number of executors for dynamic allocation.</div><div class="line">&gt;   */</div><div class="line">&gt;  def getDynamicAllocationInitialExecutors(conf: SparkConf): Int = &#123;</div><div class="line">&gt;    if (conf.get(DYN_ALLOCATION_INITIAL_EXECUTORS) &lt; conf.get(DYN_ALLOCATION_MIN_EXECUTORS)) &#123;</div><div class="line">&gt;      logWarning(s&quot;$&#123;DYN_ALLOCATION_INITIAL_EXECUTORS.key&#125; less than &quot; +</div><div class="line">&gt;        s&quot;$&#123;DYN_ALLOCATION_MIN_EXECUTORS.key&#125; is invalid, ignoring its setting, &quot; +</div><div class="line">&gt;          &quot;please update your configs.&quot;)</div><div class="line">&gt;    &#125;</div><div class="line">&gt;</div><div class="line">&gt;    if (conf.get(EXECUTOR_INSTANCES).getOrElse(0) &lt; conf.get(DYN_ALLOCATION_MIN_EXECUTORS)) &#123;</div><div class="line">&gt;      logWarning(s&quot;$&#123;EXECUTOR_INSTANCES.key&#125; less than &quot; +</div><div class="line">&gt;        s&quot;$&#123;DYN_ALLOCATION_MIN_EXECUTORS.key&#125; is invalid, ignoring its setting, &quot; +</div><div class="line">&gt;          &quot;please update your configs.&quot;)</div><div class="line">&gt;    &#125;</div><div class="line">&gt;</div><div class="line">&gt;    val initialExecutors = Seq(</div><div class="line">&gt;      conf.get(DYN_ALLOCATION_MIN_EXECUTORS),</div><div class="line">&gt;      conf.get(DYN_ALLOCATION_INITIAL_EXECUTORS),</div><div class="line">&gt;      conf.get(EXECUTOR_INSTANCES).getOrElse(0)).max</div><div class="line">&gt;</div><div class="line">&gt;    logInfo(s&quot;Using initial executors = $initialExecutors, max of &quot; +</div><div class="line">&gt;      s&quot;$&#123;DYN_ALLOCATION_INITIAL_EXECUTORS.key&#125;, $&#123;DYN_ALLOCATION_MIN_EXECUTORS.key&#125; and &quot; +</div><div class="line">&gt;        s&quot;$&#123;EXECUTOR_INSTANCES.key&#125;&quot;)</div><div class="line">&gt;    initialExecutors</div><div class="line">&gt;  &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Request a number of executors from the cluster manager.</div><div class="line"> * If the cap on the number of executors is reached, give up and reset the</div><div class="line"> * number of executors to add next round instead of continuing to double it.</div><div class="line"> *</div><div class="line"> * @param maxNumExecutorsNeeded the maximum number of executors all currently running or pending</div><div class="line"> *                              tasks could fill</div><div class="line"> * @return the number of additional executors actually requested.</div><div class="line"> */</div><div class="line">// 这里的参数maxNumExecutorNeeded = ceil(pending的task个数/每个task需要的Executor个数)</div><div class="line">private def addExecutors(maxNumExecutorsNeeded: Int): Int = &#123;</div><div class="line">  // Do not request more executors if it would put our target over the upper bound</div><div class="line">  if (numExecutorsTarget &gt;= maxNumExecutors) &#123;</div><div class="line">    logDebug(s&quot;Not adding executors because our current target total &quot; +</div><div class="line">      s&quot;is already $numExecutorsTarget (limit $maxNumExecutors)&quot;)</div><div class="line">    numExecutorsToAdd = 1</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  val oldNumExecutorsTarget = numExecutorsTarget</div><div class="line">  // There&apos;s no point in wasting time ramping up to the number of executors we already have, so</div><div class="line">  // make sure our target is at least as much as our current allocation:</div><div class="line">  numExecutorsTarget = math.max(numExecutorsTarget, executorIds.size)</div><div class="line">  // Boost our target with the number to add for this round:</div><div class="line">  numExecutorsTarget += numExecutorsToAdd</div><div class="line">  // Ensure that our target doesn&apos;t exceed what we need at the present moment:</div><div class="line">  // 保证请求不会超过现在pending的task所需要的Executor的个数</div><div class="line">  numExecutorsTarget = math.min(numExecutorsTarget, maxNumExecutorsNeeded)</div><div class="line">  // Ensure that our target fits within configured bounds:</div><div class="line">  // 保证不会超过设置最大的个数，不会小于设置最小的个数</div><div class="line">  numExecutorsTarget = math.max(math.min(numExecutorsTarget, maxNumExecutors), minNumExecutors)</div><div class="line"></div><div class="line">  // 现在需要的和上一把需要的差值（这一把多加了numExecutorsToAdd），</div><div class="line">  // 也就是这一把需要多申请delta个Executor</div><div class="line">  val delta = numExecutorsTarget - oldNumExecutorsTarget</div><div class="line"></div><div class="line">  // If our target has not changed, do not send a message</div><div class="line">  // to the cluster manager and reset our exponential growth</div><div class="line">  if (delta == 0) &#123;</div><div class="line">    numExecutorsToAdd = 1</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 这里的client是SparkContext.this</div><div class="line">  val addRequestAcknowledged = testing ||</div><div class="line">    client.requestTotalExecutors(numExecutorsTarget, localityAwareTasks, hostToLocalTaskCount)</div><div class="line">  if (addRequestAcknowledged) &#123;</div><div class="line">    val executorsString = &quot;executor&quot; + &#123; if (delta &gt; 1) &quot;s&quot; else &quot;&quot; &#125;</div><div class="line">    logInfo(s&quot;Requesting $delta new $executorsString because tasks are backlogged&quot; +</div><div class="line">      s&quot; (new desired total will be $numExecutorsTarget)&quot;)</div><div class="line">    numExecutorsToAdd = if (delta == numExecutorsToAdd) &#123;</div><div class="line">      numExecutorsToAdd * 2</div><div class="line">    &#125; else &#123;</div><div class="line">      1</div><div class="line">    &#125;</div><div class="line">    delta</div><div class="line">  &#125; else &#123;</div><div class="line">    logWarning(</div><div class="line">      s&quot;Unable to reach the cluster manager to request $numExecutorsTarget total executors!&quot;)</div><div class="line">    numExecutorsTarget = oldNumExecutorsTarget</div><div class="line">    0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="SparkContext-scala"><a href="#SparkContext-scala" class="headerlink" title="SparkContext.scala"></a>SparkContext.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&gt;   /**</div><div class="line">&gt;   * Update the cluster manager on our scheduling needs. Three bits of information are included</div><div class="line">&gt;   * to help it make decisions.</div><div class="line">&gt;   * @param numExecutors The total number of executors we&apos;d like to have. The cluster manager</div><div class="line">&gt;   *                     shouldn&apos;t kill any running executor to reach this number, but,</div><div class="line">&gt;   *                     if all existing executors were to die, this is the number of executors</div><div class="line">&gt;   *                     we&apos;d want to be allocated.</div><div class="line">&gt;   * @param localityAwareTasks The number of tasks in all active stages that have a locality</div><div class="line">&gt;   *                           preferences. This includes running, pending, and completed tasks.</div><div class="line">&gt;   * @param hostToLocalTaskCount A map of hosts to the number of tasks from all active stages</div><div class="line">&gt;   *                             that would like to like to run on that host.</div><div class="line">&gt;   *                             This includes running, pending, and completed tasks.</div><div class="line">&gt;   * @return whether the request is acknowledged by the cluster manager.</div><div class="line">&gt;   */</div><div class="line">&gt;  private[spark] override def requestTotalExecutors(</div><div class="line">&gt;      numExecutors: Int,</div><div class="line">&gt;      localityAwareTasks: Int,</div><div class="line">&gt;      hostToLocalTaskCount: scala.collection.immutable.Map[String, Int]</div><div class="line">&gt;    ): Boolean = &#123;</div><div class="line">&gt;    schedulerBackend match &#123;</div><div class="line">&gt;      // 所以就是去调用CoarseGrainedSchedulerBackend.requestTotalExecutors</div><div class="line">&gt;      case b: CoarseGrainedSchedulerBackend =&gt;</div><div class="line">&gt;        b.requestTotalExecutors(numExecutors, localityAwareTasks, hostToLocalTaskCount)</div><div class="line">&gt;      case _ =&gt;</div><div class="line">&gt;        logWarning(&quot;Requesting executors is only supported in coarse-grained mode&quot;)</div><div class="line">&gt;        false</div><div class="line">&gt;    &#125;</div><div class="line">&gt;  &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="scheduler-cluster-CoarseGrainedSchedulerBackend-scala"><a href="#scheduler-cluster-CoarseGrainedSchedulerBackend-scala" class="headerlink" title="scheduler/cluster/CoarseGrainedSchedulerBackend.scala"></a>scheduler/cluster/CoarseGrainedSchedulerBackend.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final override def requestTotalExecutors(</div><div class="line">    numExecutors: Int,  // 表示当前一共要多少Executor（包括已经申请的吧）</div><div class="line">    localityAwareTasks: Int,</div><div class="line">    hostToLocalTaskCount: Map[String, Int]</div><div class="line">  ): Boolean = synchronized &#123;</div><div class="line">  if (numExecutors &lt; 0) &#123;</div><div class="line">    throw new IllegalArgumentException(</div><div class="line">      &quot;Attempted to request a negative number of executor(s) &quot; +</div><div class="line">        s&quot;$numExecutors from the cluster manager. Please specify a positive number!&quot;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  this.localityAwareTasks = localityAwareTasks</div><div class="line">  this.hostToLocalTaskCount = hostToLocalTaskCount</div><div class="line"></div><div class="line">  numPendingExecutors =</div><div class="line">    math.max(numExecutors - numExistingExecutors + executorsPendingToRemove.size, 0)</div><div class="line">  // 调用子类函数</div><div class="line">  doRequestTotalExecutors(numExecutors)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="scheduler-cluster-mesos-MesosCoarseGrainedSchedulerBackend-scala"><a href="#scheduler-cluster-mesos-MesosCoarseGrainedSchedulerBackend-scala" class="headerlink" title="scheduler/cluster/mesos/MesosCoarseGrainedSchedulerBackend.scala"></a>scheduler/cluster/mesos/MesosCoarseGrainedSchedulerBackend.scala</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override def doRequestTotalExecutors(requestedTotal: Int): Boolean = &#123;</div><div class="line">  // We don&apos;t truly know if we can fulfill the full amount of executors</div><div class="line">  // since at coarse grain it depends on the amount of slaves available.</div><div class="line">  logInfo(&quot;Capping the total amount of executors to &quot; + requestedTotal)</div><div class="line">  executorLimitOption = Some(requestedTotal)</div><div class="line">  true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以这整个过程就是在更新<code>executorLimitOption</code>，等到mesos主动offer资源的时候，可以用到这个值来判断offer的资源够不够用。  </p>
<p>其他的内容就要看Mesos的resourceOffer了，就不属于这篇文章的介绍范围啦。再见！  </p>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/07/08/2017-07-08-unity-animation/" class="pre">unity-animation</a><a href="/2017/03/06/2017-03-06-swprintf/" class="next">来聊一聊C++的string</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Catégories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Beijing/">Beijing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C语言学习笔记/">C语言学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spark/">Spark</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spark/RDD/">RDD</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Spark/RDD/source-code/">source code</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spark/configuration/">configuration</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/coding/">coding</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/coding/compiler/">compiler</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/dp/">dp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/language/">language</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/language/Japanese/">Japanese</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/language/Japanese/lyric/">lyric</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/HashTable/">HashTable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/Two-Pointers/">Two Pointers</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/divide-and-conquer/">divide and conquer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/dp/">dp</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mapreduce/">mapreduce</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/music/guitar/">guitar</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/paper/">paper</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/paper/NLP/">NLP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/paper/scheduler/">scheduler</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming-language/">programming language</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/python/matplotlib/">matplotlib</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineer/">software engineer</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/software-engineer/API/">API</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/source-code/">source code</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/source-code/JXIO/">JXIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/source-code/Spark/">Spark</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unity/">unity</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/unity/animation/">animation</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Récent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/08/2017-07-08-unity-animation/">unity-animation</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/09/2017-04-09-dynamic-resource-allocation/">Dynamic Resource Allocation</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/2017-03-06-swprintf/">来聊一聊C++的string</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/13/2016-08-13-beijing/">出去玩-北京</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/31/2016-05-31-running-spark-on-mesos/">Running Spark on Mesos</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/12/2016-04-12-spark-summary/">Spark小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/2016-03-25-the-number-of-the-increasing-sub-sequences/">一个数组的递增子序列的个数</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/13/2015-12-13-factorial-nonzero-suffix/">求N!的后9位不为0的数</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/24/2015-09-24-recent-performance-improvements-in-apache-spark/">Recent Performance Improvements in Apache Spark: SQL, Python, DataFrame, and More</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/15/2015-08-15-matplotlib/">Matplotlib整理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> À suivre</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">ShallWe Talk.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><script src="//dn-lbstatics.qbox.me/lbservice/busuanzi/2.0/busuanzi.mini.js"/></script>
<span id="busuanzi_container_site_uv">已经有<span id="busuanzi_value_site_uv"></span>人次访问carolz的小站啦 ( •̀ ω •́ )y</span></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>